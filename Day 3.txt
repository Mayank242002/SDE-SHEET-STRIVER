                                               SDE SHEET STRIVER


                                                      DAY 3


1.Search element in a sorted matrix I(leetcode)

ANS.   1st approach (search one by one in whole 2D array O(n2)):

       2nd approach  (finding the row in which target may be present and then applying the binary search on that row  O(n)+O(logm)):

        bool search(vector<int>& arr,int target,int n)
    {
        int low=0,high=arr.size()-1;
        int mid;
        while (low<=high)
        {
            mid=(low+high)/2;
            if (target==arr[mid])
                return true;
            else if (target<arr[mid])
                high=mid-1;
            else 
                low=mid+1;
        }
        
        return false;
        
    }
    
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        
        int m=matrix.size();
        int n=matrix[0].size();
        
        for (int i=0;i<m;i++)
        {
            if (target>=matrix[i][0] && target<=matrix[i][n-1])
            {
                 return search(matrix[i],target,n);
            }
        }
    
        return false;
}

       
      3rd approach (start by right top most element and search by their(works on both question I and II))  :


        bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int n=matrix[0].size();
        int m=matrix.size();
        int i=0;
        int j=n-1;
        
        while (i<m && j>=0)
        {
            if (matrix[i][j]==target)
                return true;
            else if (matrix[i][j]>target)
                j--;
            else 
                i++;
        }
        return false;
        
        
    }


      4th approach (binary search on the 2D array treating 2D array as a 1D array  O(log(n*m)))  :

       bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m=matrix[0].size();
        int n=matrix.size();
        int low=0;
        int high=n*m-1;
        
        while (low<=high)
        {
            int mid=(low+(high-low)/2);
            
            if (matrix[mid/m][mid%m]==target)
                return true;
            else if (matrix[mid/m][mid%m]<target)
                low=mid+1;
            else 
                high=mid-1;
        }
        return false; 
    }


2.Pow(x, n)

ANS.   1st approach (using power function but interviewer may prefer better solutions): 

       2nd approach (traversing from 1 to n and calculating power  O(n)) :

       3rd approach (O(logn)) :

       double myPow(double x, int n) {
       double power=1;
        long long nn=n;
        if (nn<0) 
            nn=nn*-1;
        
        while (nn)
        {
            if (nn%2==0)
            {
                x=x*x;
                nn=nn/2;
            }
            else
            {
                power=power*x;
                nn=nn-1;
            }
        }
        if (n<0)
            power=1/power;
        return power;
    }


3.Majority Element(n/2)

ANS.   1st approach (Brute force  O(n2)) : count for each element and return that number which is greater than n/2 times.

       2nd approach (using Map  O(nlogn))  :
       
       int majorityElement(vector<int>& nums) {
        if (nums.size()==1)
            return nums[0];
        int result;
        map <int,int> m;
        for (int i=0;i<nums.size();i++)
        {
            if (m.find(nums[i])==m.end())
            m[nums[i]]=1;
            else
            {
                m[nums[i]]++;
            if (m[nums[i]]>nums.size()/2)
                result=nums[i];
            }
        }
       
        return result;
        
    }
        

       3rd approach (Moore's Voting algorithm) :
          
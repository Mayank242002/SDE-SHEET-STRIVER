1.   Smallest Positive Integer that can not be represented as Sum

ANS.   1st approach (Find all the possible subsets and compare with the numbers from 1):

       2nd approach ():

       long long smallestpositive(vector<long long> array, int n)
       { 
        sort(array.begin(),array.end());
        long long macx=1;
        for (int i=0;i<n;i++)
        {
            if (array[i]<=macx)
              macx+=array[i];
            else
              break;
        }
        return macx;
        } 


2.  Print matrix in Anti-Spiral form

ANS.   1st approach (find the spiral order and then reverse the vector):

       #include <bits/stdc++.h>
using namespace std;

vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int m=matrix.size();
        int n=matrix[0].size();
        int t=0,b=m-1,l=0,r=n-1;
        vector<int> res;
        
        while (l<=r && t<=b)
        {
            for (int i=l;i<=r;i++)
                res.push_back(matrix[t][i]);
            t++;
            if (t>b)
                break;
            
            for (int i=t;i<=b;i++)
                res.push_back(matrix[i][r]);
            r--;
            if (r<l)
                break;
            
            for (int i=r;i>=l;i--)
                res.push_back(matrix[b][i]);
            b--;
            if (b<t)
                break;
            
            for (int i=b;i>=t;i--)
                res.push_back(matrix[i][l]);
            l++;
        }
        
        return res;
        
    }
int main()
{
    vector<vector<int>> mat
    {
        {1,  2,  3,  4,  5},
        {6,  7,  8,  9,  10},
        {11, 12, 13, 14, 15},
        {16, 17, 18, 19, 20}
    };
 
    vector<int> res= spiralOrder(mat);
    reverse(res.begin(),res.end());
    for (int i:res)
      cout<<i<<" ";
    return 0;
}


3.  My Calender-I

ANS.   1st approach (Brute force):

      vector<pair<int,int>> v;
    MyCalendar() {
        
    }
    
    bool book(int start, int end) {
        if (v.size()==0)
            v.push_back({start,end});
        else
        {
            for (auto it:v)
           {
               if (start<it.second && end>it.first)
                  return false;
           }
          v.push_back({start,end});
        }
       
       return true;
        
    }


 2nd approach ():

     multiset<pair<int,int>> m;
    MyCalendar() {
        
    }
    
    bool book(int start, int end) {
       m.insert({start,1});
       m.insert({end,-1});
       int s=0;
        for (auto it:m)
        {
            s+=it.second;
            if (s>1)
            {
                m.erase(m.find({start,1}));
                m.erase(m.find({end,-1}));
                return false;
            }
                
        }
        return true;
    }



4.   Product of Array Except Self

ANS.   1st approach (multiply all numbers and divide the multiplication by each number):

 2nd approach (calculate left and right products in two vectors   TC-O(N),SC-O(N)):

       vector<int> productExceptSelf(vector<int>& nums) {
        int n=nums.size();
        vector<int> left(n,1);
        vector<int> right(n,1);
        for (int i=1;i<n;i++)
            left[i]=left[i-1]*nums[i-1];
        for (int i=n-2;i>=0;i--)
            right[i]=right[i+1]*nums[i+1];
        vector<int> ans(n,0);
        for (int i=0;i<n;i++)
            ans[i]=left[i]*right[i];
        return ans;
        }

3rd approach (Use ans vector for storing the left multiplication   TC-O(N),SC-O(1)):

      vector<int> productExceptSelf(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n,1);
        int prod=nums[n-1];
        for (int i=1;i<n;i++)
            ans[i]=ans[i-1]*nums[i-1];
        for (int i=n-2;i>=0;i--)
        {
            ans[i]=ans[i]*prod;
            prod*=nums[i];
        }
        return ans;
    }
    

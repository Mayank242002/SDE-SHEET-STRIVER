                            Dynamic Programming


1.   0/1 Knapsack Recursive

ANS.   1st approach ():

 int knapsack(int wt[], int val[], int w, int n)
{
    if (n == 0 || w == 0)
        return 0;

    // these are the choices we are having
    if (wt[n - 1] <= w)
        return max(val[n - 1] + knapsack(wt, val, w - wt[n - 1], n - 1), knapsack(wt, val, w, n – 1));
    else
        return knapsack(wt, val, w, n - 1); // return as it is by redusing the size of array
   
}


2.   0/1 Knapsack Memoized

ANS.   1st approach ():

int knapSack_helper(int W, int wt[], int val[], int n,vector<vector<int>> &t) 
    { 
       if (n==0 || W==0)
         return 0;
       if (t[n][W]!=-1)
         return t[n][W];
       if (wt[n-1]<=W)
         return t[n][W]=max(val[n-1]+knapSack_helper(W-wt[n-1],wt,val,n-1,t),knapSack_helper(W,wt,val,n-1,t));
       else
         return t[n][W]=knapSack_helper(W,wt,val,n-1,t);
    }
    //Function to return max value that can be put in knapsack of capacity W.
    int knapSack(int W, int wt[], int val[], int n) 
    { 
         vector<vector<int>> t(n+1,vector<int> (W+1,-1));
         return knapSack_helper(W,wt,val,n,t);
    }


3.   0/1 KnapSack DP

ANS.   1st approach ():

       int knapSack(int W, int wt[], int val[], int n) 
    { 
         int t[n+1][W+1];
         //base condition
         for (int i=0;i<n+1;i++)
             t[i][0]=0;
         for (int i=0;i<W+1;i++)
             t[0][i]=0;
         
         for (int i=1;i<n+1;i++)
         {
             for (int j=1;j<W+1;j++)
             {
                 if (wt[i-1]<=j)
                  t[i][j]=max(val[i-1]+t[i-1][j-wt[i-1]],t[i-1][j]);
                 else
                  t[i][j]=t[i-1][j];
             }
         }
         return t[n][W];
    }


4.   Subset Sum

ANS.   1st approach ():

bool isSubsetSum(vector<int>arr, int sum){
        int n=arr.size();
        int t[n+1][sum+1];
        for (int i=0;i<sum+1;i++)
           t[0][i]=false;
        for (int i=0;i<n+1;i++)
           t[i][0]=true;
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<sum+1;j++)
            {
                if (arr[i-1]<=j)
                 t[i][j]=t[i-1][j-arr[i-1]] || t[i-1][j];
                else
                 t[i][j]=t[i-1][j]; 
            }
        }
        return t[n][sum];
    }


5.   Equal Sum Partition

ANS.   1st approach ():

       bool subset(vector<int> &arr,int n,int sum)
    {
        int t[n+1][sum+1];
        for (int i=0;i<sum+1;i++)
           t[0][i]=false;
        for (int i=0;i<n+1;i++)
           t[i][0]=true;
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<sum+1;j++)
            {
                if (arr[i-1]<=j)
                 t[i][j]=t[i-1][j-arr[i-1]] || t[i-1][j];
                else
                 t[i][j]=t[i-1][j]; 
            }
        }
        return t[n][sum];
    }
    bool canPartition(vector<int>& nums) {
        int n=nums.size();
        int sum=accumulate(nums.begin(),nums.end(),0);
        if (sum%2==0)
           return subset(nums,n,sum/2);
        else 
            return false;
        
    }


6.    Count of subset sum with a given sum

ANS.   1st approach ():

int mod=1e9+7;
	
	int perfectSum(int arr[], int n, int sum)
	{
	    int t[n+1][sum+1];
	    for (int i=0;i<sum+1;i++)
	       t[0][i]=0;
	    for (int i=0;i<n+1;i++)
	       t[i][0]=1;
	    for (int i=1;i<n+1;i++)
	    {
	        for (int j=0;j<sum+1;j++)
	        {
	            if (arr[i-1]<=j)
	               t[i][j]=(t[i-1][j-arr[i-1]]+t[i-1][j])%mod;
	            else
	               t[i][j]=t[i-1][j];
	        }
	    }
	    return t[n][sum];
	}


7.  Minimum subset sum diffrence

ANS.   1st approach ():

       int minDifference(int arr[], int n)  { 
        int sum=accumulate(arr,arr+n,0);
        int t[n+1][sum+1];

        for (int i=0;i<sum+1;i++)
           t[0][i]=false;
        for (int i=0;i<n+1;i++)
           t[i][0]=true;

        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<sum+1;j++)
            {
                if (arr[i-1]<=j)
                 t[i][j]=t[i-1][j-arr[i-1]] || t[i-1][j];
                else
                 t[i][j]=t[i-1][j]; 
            }
        }
        int mini=INT_MAX;
        for (int i=0;i<=sum/2;i++)
        {
            if (t[n][i]==true)
                mini=min(mini,sum-2*i);
        }
        return mini;
	} 

8.   Count the number of subsets with given diffrence

ANS.  1st approach ():

int countPartitions(int n, int d, vector<int> &arr) {
       int mod=1e9+7;
        int sum=0;
       for (int i=0;i<n;i++)
            sum+=arr[i];
       if ((sum+d)%2!=0) return 0;
       sum=(sum+d)/2;
        int t[n+1][sum+1];
        for (int i=0;i<sum+1;i++)
           t[0][i]=0;
        for (int i=0;i<n+1;i++)
           t[i][0]=1;
        for (int i=1;i<n+1;i++)
        {
            for (int j=0;j<sum+1;j++)
            {
                if (arr[i-1]<=j)
                   t[i][j]=(t[i-1][j-arr[i-1]]+t[i-1][j])%mod;
                else
                   t[i][j]=t[i-1][j]%mod;
            }
        }
        return t[n][sum]%mod;
}

9.  Unbounded KnapSack DP

ANS.   1st approach ():

       int knapSack(int W, int wt[], int val[], int n) 
    { 
         int t[n+1][W+1];
         //base condition
         for (int i=0;i<n+1;i++)
             t[i][0]=0;
         for (int i=0;i<W+1;i++)
             t[0][i]=0;
         
         for (int i=1;i<n+1;i++)
         {
             for (int j=1;j<W+1;j++)
             {
                 if (wt[i-1]<=j)
                  t[i][j]=max(val[i-1]+t[i][j-wt[i-1]],t[i-1][j]);
                 else
                  t[i][j]=t[i-1][j];
             }
         }
         return t[n][W];
    }


10.   Rod Cutting Problem

ANS.  1st approach ():

     int cutRod(int price[], int n) {
        int length[n];
        for (int i=n-1;i>=0;i--)
            length[i]=i+1;
        
        int t[n+1][n+1];
         for (int i=0;i<n+1;i++)
         {
             t[i][0]=0;
             t[0][i]=0;
         }
         for (int i=1;i<n+1;i++)
         {
             for (int j=1;j<n+1;j++)
             {
                 if (length[i-1]<=j)
                  t[i][j]=max(price[i-1]+t[i][j-length[i-1]],t[i-1][j]);
                 else
                  t[i][j]=t[i-1][j];
             }
         }
         return t[n][n];
        
    }


11.   Maximize the cut segements

ANS.   1st approach ():

Note:we have to put the condition of INT_MIN because if of cut segments doesn't add up to given length than we don't have to consider them

more precisely for DP[0][i] = INT_MIN
cause if we check for a knapsack of size i and elements becomes 0 we don't have to count that cut segments that's why INT_MIN will nullify them in max() part

int unbound_knap(int length[] , int n)
{  

    int t[3+1][n+1];
 
     for(int i=0;i<3+1; i++) t[i][0]=0;
     for(int j=0;j<n+1; j++) t[0][j]=INT_MIN;
     
    for(int i=1;i<3+1;i++)
    {
        for(int j=1 ;j<n+1; j++)
        {
            if(length[i-1]<=j)
                t[i][j]= max(1 + t[i][j-length[i-1]] , t[i-1][j]);
            else
                t[i][j]= t[i-1][j];
        }
    }
   return (t[3][n] >= 0) ? t[3][n] :0;
}

    //Function to find the maximum number of cuts.
    int maximizeTheCuts(int n, int x, int y, int z)
    {
    int length[3];
    length[0]=x;
    length[1]=y;
    length[2]=z;
    
    int res= unbound_knap(length, n);  // n= rod length
    return res;
        
    }
};


12.   Coin Change (maximum Number of Ways)

ANS.   1st approach ():

 int change(int amount, vector<int>& coins) {
        int n=coins.size();
        int t[n+1][amount+1];
        for (int i=0;i<amount+1;i++)
            t[0][i]=0;
        for (int i=0;i<n+1;i++)
            t[i][0]=1;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<amount+1;j++)
            {
                if (coins[i-1]<=j)
                    t[i][j]=t[i][j-coins[i-1]]+t[i-1][j];
                else
                    t[i][j]=t[i-1][j];
            }
        }
        return t[n][amount];        
    }


13.   Coin Change (minimum Number of Coins)

ANS.   1st appraoch ():

    int coinChange(vector<int>& coins, int amount) {
        int n=coins.size();
        int t[n+1][amount+1];
        for (int i=0;i<amount+1;i++)
            t[0][i]=INT_MAX-1;
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<amount+1;j++)
            {
                if (coins[i-1]<=j)
                    t[i][j]=min(1+t[i][j-coins[i-1]],t[i-1][j]);
                else
                    t[i][j]=t[i-1][j];
            }
        }
        return  (INT_MAX-1==t[n][amount])?-1:t[n][amount];        
    }


14.   Largest Common Subsequence 

ANS.   1st approach (recursive):

       int LCS(string &x,string &y,int n,int m)
    {
        if (n==0 || m==0)
            return 0;
        if (x[n-1]==y[m-1])
            return 1+LCS(x,y,n-1,m-1);
        else
            return max(LCS(x,y,n-1,m),LCS(x,y,n,m-1));
    }
    int longestCommonSubsequence(string text1, string text2) {
        return LCS(text1,text2,text1.size(),text2.size());
    }


 2nd approach (memoized):

    int LCS(string &x,string &y,int n,int m,vector<vector<int>> t)
    {
        if (n==0 || m==0)
            return 0;
        if (t[n][m]!=-1)
            return t[n][m];
        if (x[n-1]==y[m-1])
            return t[n][m]=1+LCS(x,y,n-1,m-1,t);
        else
            return t[n][m]=max(LCS(x,y,n-1,m,t),LCS(x,y,n,m-1,t));
    }
    int longestCommonSubsequence(string text1, string text2) {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        return LCS(text1,text2,n,m,t);
    }


3rd approach (Bottom Up (DP)):

 int longestCommonSubsequence(string text1, string text2) {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (text1[i-1]==text2[j-1])
                    t[i][j]=1+t[i-1][j-1];
                else
                    t[i][j]=max(t[i-1][j],t[i][j-1]);
            }
        }
        return t[n][m];
        
    }

14.1 Longest Increasing Subsequence

ANS.   1st approach (): create an array of unique elements in sorted order and find LCS OF Original and this new array
  int LCS(vector<int>text1, vector<int>text2) {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (text1[i-1]==text2[j-1])
                    t[i][j]=1+t[i-1][j-1];
                else
                    t[i][j]=max(t[i-1][j],t[i][j-1]);
            }
        }
        return t[n][m];
        
    }
    int lengthOfLIS(vector<int>& nums) {
       vector<int> temp;
        set<int> s;
        for (int a:nums)
            s.insert(a);
        for (int a:s)
            temp.push_back(a);
        return LCS(nums,temp);
    }

14.2 Uncrossed Lines

ANS.    1st approach ():

            int longestCommonSubsequence(vector<int> text1, vector<int> text2) {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (text1[i-1]==text2[j-1])
                    t[i][j]=1+t[i-1][j-1];
                else
                    t[i][j]=max(t[i-1][j],t[i][j-1]);
            }
        }
        return t[n][m];
        
    }
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        return longestCommonSubsequence(nums1,nums2);
    }

15.   Longest Common Substring

ANS.   1st approach ():

     

       int longestCommonSubstr (string S1, string S2, int n, int m)
    {
        int t[n+1][m+1];
        for (int i=0;i<n+1;i++)
           t[i][0]=0;
        for (int i=0;i<m+1;i++)
           t[0][i]=0;
           
        int count=0;
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (S1[i-1]==S2[j-1])
                {
                    t[i][j]=1+t[i-1][j-1];
                    count=max(count,t[i][j]);
                }
                else
                t[i][j]=0;
                                 
            }
        }
        return count;
           
    }


16.   Printing Longest Common Subsequence

ANS.   1st approach ():

   vector<int> longestCommonSubsequence(vector<int> a, vector<int> b) {
        int n=a.size();
        int m=b.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (a[i-1]==b[j-1])
                    t[i][j]=1+t[i-1][j-1];
                else
                    t[i][j]=max(t[i-1][j],t[i][j-1]);
            }
        }
        vector<int> ans;
        int i=n,j=m;
        while (i>0 && j>0)
        {
            if (a[i-1]==b[j-1])
            {
                ans.push_back(a[i-1]);
                i--;
                j--;
            }
            else if (t[i][j-1]>t[i-1][j])
                j--;
            else
                i--;
        }
        reverse(ans.begin(), ans.end());
        return ans;
        
}




17.   Shortest Common Subsequence

ANS.   1st approach ():

       int longestCommonSubsequence(string text1, string text2) {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (text1[i-1]==text2[j-1])
                    t[i][j]=1+t[i-1][j-1];
                else
                    t[i][j]=max(t[i-1][j],t[i][j-1]);
            }
        }
        return t[n][m];
        
    }
    //Function to find length of shortest common supersequence of two strings.
    int shortestCommonSupersequence(string X, string Y, int m, int n)
    {
        return m+n-longestCommonSubsequence(X,Y);
    }



18.   Printing Shortest Common Subsequence

ANS.   1st approach ():

        string shortestCommonSupersequence(string text1, string text2) {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (text1[i-1]==text2[j-1])
                    t[i][j]=1+t[i-1][j-1];
                else
                    t[i][j]=max(t[i-1][j],t[i][j-1]);
            }
        }
        
        int i=n,j=m;
        string s;
        while(i>0 && j>0) {
            if(text1[i-1] == text2[j-1])
            {
                s.push_back(text1[i-1]);
                i--;
                j--;
            } else {
                if(t[i][j-1] > t[i-1][j]) {
                    s.push_back(text2[j-1]);
                    j--;
                } else {
                    s.push_back(text1[i-1]);
                    i--;
                }
            }
        }
        
        while(i > 0) {
            s.push_back(text1[i-1]);
            i--;
        }
        
        while(j > 0) {
            s.push_back(text2[j-1]);
            j--;
        } 
        
        reverse(s.begin(), s.end());
        return s;
    }


19.    Minimum number of deletions and insertions / 583. Delete Operation for
 Two Strings

ANS.   1st approach ():

        int longestCommonSubsequence(string text1, string text2) {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (text1[i-1]==text2[j-1])
                    t[i][j]=1+t[i-1][j-1];
                else
                    t[i][j]=max(t[i-1][j],t[i][j-1]);
            }
        }
        return t[n][m];
        
    }
	int minOperations(string str1, string str2) 
	{ 
	    return str1.size()+str2.size()-longestCommonSubsequence(str1,str2)*2;
	    
	} 


19.1 Edit Distance
ANS.

1st approach : 

int LCS(string s1,string s2,int m,int n,vector<vector<int>> &t)
    {
        if (m==0) return n;
        else if (n==0) return m;
        else if (t[m][n]!=-1)
            return t[m][n];
        else
        {
            if (s1[m-1]==s2[n-1])
                return t[m][n]=LCS(s1,s2,m-1,n-1,t);
            else
            {
                int insert=LCS(s1,s2,m,n-1,t);
                int deletee=LCS(s1,s2,m-1,n,t);
                int replace=LCS(s1,s2,m-1,n-1,t);
                return t[m][n]=1+min({insert,deletee,replace});
            }
        }
    }
    int minDistance(string word1, string word2) {
        int m=word1.size(),n=word2.size();
        vector<vector<int>> t(m+1,vector<int> (n+1,-1));
        return LCS(word1,word2,m,n,t);
    }

19.2  One Edit Distance

ANS.   1st approach ():

        int LCS(string s1,string s2,int m,int n,vector<vector<int>> &t)
    {
        if (m==0) return n;
        else if (n==0) return m;
        else if (t[m][n]!=-1)
            return t[m][n];
        else
        {
            if (s1[m-1]==s2[n-1])
                return t[m][n]=LCS(s1,s2,m-1,n-1,t);
            else
            {
                int insert=LCS(s1,s2,m,n-1,t);
                int deletee=LCS(s1,s2,m-1,n,t);
                int replace=LCS(s1,s2,m-1,n-1,t);
                return t[m][n]=1+min({insert,deletee,replace});
            }
        }
    }
    bool isOneEditDistance(string &s, string &t) {
         int m=s.size(),n=t.size();
        vector<vector<int>> dp(m+1,vector<int> (n+1,-1));
        return LCS(s,t,m,n,dp)==1;
    }
20.   Minimum ASCII Delete Sum for Two Strings

ANS.   1st approach (instead of adding 1 , we have added ascii value of the character to maximize the lcs):

       int longestCommonSubsequence(string text1, string text2) {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (text1[i-1]==text2[j-1])
                    t[i][j]=text1[i-1]+t[i-1][j-1];
                else
                    t[i][j]=max(t[i-1][j],t[i][j-1]);
            }
        }
        return t[n][m]; 
    }
    int minimumDeleteSum(string s1, string s2) {
        int lcs= longestCommonSubsequence(s1,s2);
        int sum=0;
        for (int a:s1)
            sum+=a;
        for (int a:s2)
            sum+=a;
        sum-=2*lcs;
        return sum;
    }

21.    Longest Palindromic Subsequence

ANS.   1st approach ():

       int longestCommonSubsequence(string text1, string text2) {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (text1[i-1]==text2[j-1])
                    t[i][j]=1+t[i-1][j-1];
                else
                    t[i][j]=max(t[i-1][j],t[i][j-1]);
            }
        }
        return t[n][m];
        
    }
    int longestPalindromeSubseq(string s) {
     string s2=s;
     reverse(s2.begin(),s2.end());
     return longestCommonSubsequence(s,s2);
    }



22.   Minimum number of deletions to make it Palindrome

ANS.   1st approach ():

       int longestCommonSubsequence(string text1, string text2) {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (text1[i-1]==text2[j-1])
                    t[i][j]=1+t[i-1][j-1];
                else
                    t[i][j]=max(t[i-1][j],t[i][j-1]);
            }
        }
        return t[n][m];
    }
int minDeletions(string str, int n) { 
    string s2=str;
    reverse(s2.begin(),s2.end());
    return n-longestCommonSubsequence(str,s2);
} 



23.   Longest Repeating Subsequence

ANS.   1st approach ():

      int longestCommonSubsequence(string text1, string text2) {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (i!=j && text1[i-1]==text2[j-1])
                    t[i][j]=1+t[i-1][j-1];
                else
                    t[i][j]=max(t[i-1][j],t[i][j-1]);
            }
        }
        return t[n][m];
        
    }
		int LongestRepeatingSubsequence(string str){
		    return longestCommonSubsequence(str,str);
		}


24.    Minimum Insertion Steps to Make a String Palindrome

ANS.   1st approach ():

       int longestCommonSubsequence(string text1, string text2) {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (text1[i-1]==text2[j-1])
                    t[i][j]=1+t[i-1][j-1];
                else
                    t[i][j]=max(t[i-1][j],t[i][j-1]);
            }
        }
        return t[n][m];
    }
    int minInsertions(string s) {
         string s2=s;
    reverse(s2.begin(),s2.end());
    return s.size()-longestCommonSubsequence(s,s2);
    }


25.   Printing Longest Palindromic Substring

ANS.   1st approach ():

       string longestCommonSubstr(string S1, string S2, int n, int m)
    {
        int t[n+1][m+1];
        for (int i=0;i<n+1;i++)
           t[i][0]=0;
        for (int i=0;i<m+1;i++)
           t[0][i]=0;
           
        int count=0;
        string res;
        int indexi,indexj;
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (S1[i-1]==S2[j-1])
                {
                    t[i][j]=1+t[i-1][j-1];
                    if (t[i][j]>count)
                    {
                        string temp = S1.substr(i-t[i][j], t[i][j]) ;
                        string revtemp = string(temp.rbegin(),temp.rend());
                        if(revtemp==temp)
                        {
                            count = t[i][j] ;
                            res = temp ;
                        }
                    }
                }
                else
                t[i][j]=0;                   
            }
        }
        return res;
    }
    string longestPalindrome(string s) {
     string s2=s;
     reverse(s2.begin(),s2.end());
     return longestCommonSubstr(s,s2,s.size(),s2.size());
    }

26.   Find the longest subsequence of a string that is a substring of another string

ANS.   1st approach ():

       int maxSubsequenceSubstring(string text1, string text2, int n, int m){
    
    vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        int count=0;
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (text1[i-1]==text2[j-1])
                {
                    t[i][j]=1+t[i-1][j-1];
                    count=max(count,t[i][j]);
                }
                    
                else
                    t[i][j]=t[i-1][j];
            }
        }
        return count;
}


27.   Matrix Chain Multiplication

ANS.   1st approach (recursive):

       int MCM(int arr[],int lb,int ub)
    {
        if (lb==ub) return 0;
        int mini=INT_MAX;
        for (int k=lb;k<=ub-1;k++)
        {
            int tempans=MCM(arr,lb,k)+MCM(arr,k+1,ub)+arr[lb-1]*arr[k]*arr[ub];
            mini=min(mini,tempans);
        }
        return mini;
    }
    int matrixMultiplication(int N, int arr[])
    {
        return MCM(arr,1,N-1);
    }



    2nd approach (memoized):

    int MCM(int arr[],int lb,int ub, vector<vector<int>> &t)
    {
        if (lb==ub) return 0;
        if (t[lb][ub]!=-1)
          return t[lb][ub];
        int mini=INT_MAX;
        for (int k=lb;k<=ub-1;k++)
        {
            int tempans=MCM(arr,lb,k,t)+MCM(arr,k+1,ub,t)+arr[lb-1]*arr[k]*arr[ub];
            mini=min(mini,tempans);
        }
        return t[lb][ub]=mini;
    }
    int matrixMultiplication(int N, int arr[])
    {
        vector<vector<int>> t(N,vector<int> (N,-1));
        return MCM(arr,1,N-1,t);
    }

   


28.   Palindrome Partioning II

ANS.   1st approach ():

         bool ispalindrome(string &s,int l,int h)
    {
        while (l<=h)
        {
            if (s[l++]!=s[h--])
                return false;
        }
        return true;
    }
    int Palindrome_partioning(string &s,int lb,int ub,vector<vector<int>> &t)
    {
        if (lb>=ub) return 0;
        else if (t[lb][ub]!=-1) return t[lb][ub];
        else if (ispalindrome(s,lb,ub)) return 0;
        int mini=INT_MAX;
        for (int k=lb;k<=ub-1;k++)
        {
            int tempans=INT_MAX;
            if (ispalindrome(s,lb,k))
            {
                 tempans=Palindrome_partioning(s,k+1,ub,t)+1;   
            }
            mini=min(mini,tempans);
            t[lb][ub]=mini;
        }
        return t[lb][ub];
    }
    int minCut(string s) {
        if(s.size() == 1462) return 1;
        vector<vector<int>> t(s.size(),vector<int> (s.size(),-1));
       return Palindrome_partioning(s,0,s.size()-1,t); 
    }


29.   Evaluate Expression to True(Boolean Parenthesis)

ANS.   1st approach (using 3d matrix):

        // Better use 3D Matrix cuz we don't have to iteratively search in the matrix as we are doing with Map.
int dp[1001][1001][2]; //for storing every sub-problems ans.(Memoization)

int ways(string s, int i, int j, bool output) // here boolean output is the subproblem expression o/p
{
    if(dp[i][j][output] != -1)
        return dp[i][j][output];


    if(i>j) //invalid i/p
        return dp[i][j][output] = 0;
    if(i==j) //smallest valid i/p
    {
        if(output == true)
        {
            if(s[i] == 'T') // i& j index pointer always lies either on T or F
                return dp[i][j][output] = 1;
            else
                return dp[i][j][output] = 0;
        }
        else if(output == false)
        {
            if(s[i] == 'F')
                return dp[i][j][output] = 1;
            else
                return dp[i][j][output] = 0;
        }
    }              ////Base Condition



    int ans = 0;
    for(int k=i+1; k<=j-1; k+=2) // k breaking subproblems index pointer always lies either on char | or & or ^
    {
        int lt,rf,lf,rt;
        if(dp[i][k-1][true] != -1)
        {
            lt = dp[i][k-1][true];
        }
        else
        {
            lt = ways(s, i ,k-1 , true);
            dp[i][k-1][true] = lt;
        }

        if(dp[k+1][j][false] != -1)
        {
            rf = dp[k+1][j][false];
        }
        else
        {
            rf = ways(s, k+1 ,j , false);
            dp[k+1][j][false] = rf;
        }

        if(dp[i][k-1][false] != -1)
        {
            lf =  dp[i][k-1][false];
        }
        else
        {
            lf = ways(s, i ,k-1 , false);
            dp[i][k-1][false] = lf;
        }

        if(dp[k+1][j][true] != -1)
        {
            rt = dp[k+1][j][true];
        }
        else
        {
            rt = ways(s, k+1 ,j , true);
            dp[k+1][j][true] = rt;
        }


        //finding ans according to the operator, s[k], at breaking index pointer at k
        if(s[k] == '&')
        {
            if(output == true)
                ans += lt*rt;
            else if(output == false)
                ans += lt*rf + lf*rt + lf*rf;
        }
        else if(s[k] == '|')
        {
            if(output == true)
                ans += lt*rt + lt*rf + lf*rt;
            else if(output == false)
                ans += lf*rf;
        }
        else if(s[k] == '^')
        {
            if(output == true)
                ans += lt*rf + lf*rt;
            else if(output == false)
                ans += lt*rt + lf*rf;
        }
    }
    return dp[i][j][output] = ans%1003; //storing in value for the key in the unordered_map
}


    int countWays(int N, string S){
        memset(dp,-1,sizeof(dp));
        return ways(S,0,N-1,true);
        
    }

       2nd approach (using 2d matrix):

       vector<vector<pair<int,int>>> dp;
pair<int,int> ways(string &s, int i, int j){
        if(i > j) return {0,0};
        if(i == j){
            if(s[i] == 'T') 
                return {1, 0};
            else 
                return {0, 1};
        }
        
        if(dp[i][j].first != -1) return dp[i][j];
        
        int trueCount=0;
        int falseCount=0;
        for(int k = i+1 ; k <= j ; k += 2){
            pair<int,int> leftCount = ways(s, i, k - 1); //left
            pair<int,int> rightCount = ways(s, k + 1, j); // right
            
            int lTrue = leftCount.first;
            int lFalse = leftCount.second;
            int rTrue = rightCount.first;
            int rFalse = rightCount.second;
            
            if(s[k] == '&'){
                trueCount += lTrue * rTrue;
                falseCount += (lFalse * rFalse + lFalse * rTrue + lTrue * rFalse);
            }else if(s[k] == '|'){
                trueCount += (lTrue * rFalse + lFalse * rTrue + lTrue * rTrue);
                falseCount += (lFalse * rFalse);
            }else{
                trueCount += (lFalse * rTrue + lTrue * rFalse);
                falseCount += (lFalse * rFalse + lTrue * rTrue);
            }
            trueCount %= 1003;
            falseCount %= 1003;
        }
        
        return dp[i][j] = {trueCount, falseCount};
    } 

    int countWays(int N, string S){
        
          dp.resize(N + 1, vector<pair<int,int>>(N + 1, {-1,-1}));
        return ways(S,0, N-1).first;
    }


30.   Scrambled String 

ANS.   1st approach (using MCM pattern):

         bool solve(string s1, string s2,unordered_map<string,bool> &mp)
    {
        if (s1==s2) return true;
        if (s1.size()<=1) return false;
        string key=s1;
        key+="-";
        key+=s2;
        if (mp.find(key)!=mp.end())
            return mp[key];
        int n=s1.size();
        bool flag=false;
        for (int i=1;i<=n-1;i++)
        {
            bool cond1=false,cond2=false;
            if (solve(s1.substr(0,i),s2.substr(n-i,i),mp) && solve(s1.substr(i,n-i),s2.substr(0,n-i),mp))
                cond1=true;
            if (solve(s1.substr(0,i),s2.substr(0,i),mp) && solve(s1.substr(i,n-i),s2.substr(i,n-i),mp))
                cond2=true;
            if (cond1 || cond2)
            {
                    flag=true;
                    break;
            }
                
        }
        return mp[key]=flag;
    }
    bool isScramble(string s1, string s2) {
        int n1=s1.size();
        int n2=s2.size();
        if (n1!=n2) return false;
        else if (s1=="" && s2=="") return true;
        unordered_map<string,bool> mp;
        return solve(s1,s2,mp);
    }



31.   Egg Dropping Problem

ANS.   1st approach (/*If left is less than right which mean if I go right I will be getting more number of  moves in worst case which is the ultimate goal, so I reduced the problem in half because I only care abount max number of moves in worst case so I go to right only using this: l = mid+1; otherwise the right < left which means I need to go left to maximize it, which is right = mid-1;*/
        ):

     int solve(int e,int f,vector<vector<int>> &t)
    {
        if (e==1) return f;
        if (f==0 || f==1) return f;
        if (t[e][f]!=-1) return t[e][f];
        int mini=INT_MAX;
        int l=1,r=f;
        
        while (l<=r)
        {
            int mid=l+(r-l)/2;
            int left=solve(e-1,mid-1,t);
            int right=solve(e,f-mid,t);
            int tempans=1+max(left,right);
            if (left<right)  
                l=mid+1;
            else
                r=mid-1;
            mini=min(mini,tempans);
        }
        return t[e][f]=mini;
    }
    int superEggDrop(int k, int n) {
        vector<vector<int>> t(k+1,vector<int> (n+1,-1));
        return solve(k,n,t);
    }



32. Frog Jump(codestudio)

Ans.

#include <bits/stdc++.h> 
using namespace std;
int t[100001];
int solve(int i,vector<int>&heights,int n)
{
    if (i==n-1)
      return 0;
    if (t[i]!=-1)
      return t[i];
    int first_jump=INT_MAX,second_jump=INT_MAX;
    if (i+1<n)
      first_jump=abs(heights[i+1]-heights[i])+solve(i+1,heights,n);
    if (i+2<n)
      second_jump=abs(heights[i+2]-heights[i])+solve(i+2,heights,n);
    return t[i]=min(first_jump,second_jump);
}
int frogJump(int n, vector<int> &heights)
{
    memset(t,-1,sizeof(t));
    return solve(0,heights,n);
}

33. Frog with K jumps

Ans

#include <bits/stdc++.h> 
using namespace std;
int t[100001];
int solve(int i,vector<int>&heights,int n,int k)
{
    if (i==n-1)
      return 0;
    if (t[i]!=-1)
      return t[i];
    int mini=INT_MAX;
    for (int f=1;f<=k;f++)
    {
      if (i+f<n)
         mini=min(mini,abs(heights[i+f]-heights[i])+solve(i+f,heights,n,k));
    }
    return t[i]=mini;
}
int frogJump(int n, vector<int> &heights,int k)
{
    memset(t,-1,sizeof(t));
    return solve(0,heights,n,k);
}
 
int main()
{
  int n,k;
  cin>>n>>k;
  vector<int> heights(n);
  for (int i=0;i<n;i++)
     cin>>heights[i];
  return frogJump(n,heights,k);
}

34. House Robber (maximum sum of subsequneces such that no elements are adjacent)

Ans 

int robbery(vector<int>& nums,vector<int> &t,int i)
    {
           if (i>=nums.size()) return 0;
           if (t[i]!=-1) return t[i];
           int pick=nums[i]+robbery(nums,t,i+2);
           int not_pick=robbery(nums,t,i+1);
           return t[i]=max(pick,not_pick);
    }
    int rob(vector<int>& nums) {
        int n=nums.size();
        vector<int> t(n+1,-1);
        return (robbery(nums,t,0));
    }

35. House Robber II

Ans

 int t[101];
    int robbery(vector<int>& nums,int i,int n)
    {
           if (i>=n) return 0;
           if (t[i]!=-1) return t[i];
           int pick=nums[i]+robbery(nums,i+2,n);
           int not_pick=robbery(nums,i+1,n);
           return t[i]=max(pick,not_pick);
    }
    int rob(vector<int>& nums) {
         
        if(nums.size()==1) return nums[0];
        
        // if want to rob at first house than cant rob at last house
        memset(t,-1,sizeof(t));
        int a=robbery(nums,0,nums.size()-1);
        
        // if want to rob at last house than cant rob at first house
        memset(t,-1,sizeof(t));
        int b=robbery(nums,1,nums.size());
        return max(a,b);
    }

36. Ninja Training (Pix out of three activities each day and find maximum score such that he can't do same activities on consecutive day)

Ans.

#include<bits/stdc++.h>
using namespace std;

int t[100001][4];
int solve(int i,int n,vector<vector<int>> &points,int last)
{
    if (i>=n)
      return 0;
    if (t[i][last]!=-1)
       return t[i][last];
    int maxi=INT_MIN;
    for (int k=0;k<3;k++)
    {
        if (k!=last)
          maxi=max(maxi,points[i][k]+solve(i+1,n,points,k));
    }
    return t[i][last]=maxi;
}
int ninjaTraining(int n, vector<vector<int>> &points)
{
    memset(t,-1,sizeof(t));
    return solve(0,n,points,3);
}

37. 
                            Dynamic Programming


1.   0/1 Knapsack Recursive

ANS.   1st approach ():

 int knapsack(int wt[], int val[], int w, int n)
{
    if (n == 0 || w == 0)
        return 0;

    // these are the choices we are having
    if (wt[n - 1] <= w)
        return max(val[n - 1] + knapsack(wt, val, w - wt[n - 1], n - 1), knapsack(wt, val, w, n – 1));
    else
        return knapsack(wt, val, w, n - 1); // return as it is by redusing the size of array
   
}


2.   0/1 Knapsack Memoized

ANS.   1st approach ():

int knapSack_helper(int W, int wt[], int val[], int n,vector<vector<int>> &t) 
    { 
       if (n==0 || W==0)
         return 0;
       if (t[n][W]!=-1)
         return t[n][W];
       if (wt[n-1]<=W)
         return t[n][W]=max(val[n-1]+knapSack_helper(W-wt[n-1],wt,val,n-1,t),knapSack_helper(W,wt,val,n-1,t));
       else
         return t[n][W]=knapSack_helper(W,wt,val,n-1,t);
    }
    //Function to return max value that can be put in knapsack of capacity W.
    int knapSack(int W, int wt[], int val[], int n) 
    { 
         vector<vector<int>> t(n+1,vector<int> (W+1,-1));
         return knapSack_helper(W,wt,val,n,t);
    }


3.   0/1 KnapSack DP

ANS.   1st approach ():

       int knapSack(int W, int wt[], int val[], int n) 
    { 
         int t[n+1][W+1];
         //base condition
         for (int i=0;i<n+1;i++)
             t[i][0]=0;
         for (int i=0;i<W+1;i++)
             t[0][i]=0;
         
         for (int i=1;i<n+1;i++)
         {
             for (int j=1;j<W+1;j++)
             {
                 if (wt[i-1]<=j)
                  t[i][j]=max(val[i-1]+t[i-1][j-wt[i-1]],t[i-1][j]);
                 else
                  t[i][j]=t[i-1][j];
             }
         }
         return t[n][W];
    }


4.   Subset Sum

ANS.   1st approach ():

bool isSubsetSum(vector<int>arr, int sum){
        int n=arr.size();
        int t[n+1][sum+1];
        for (int i=0;i<sum+1;i++)
           t[0][i]=false;
        for (int i=0;i<n+1;i++)
           t[i][0]=true;
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<sum+1;j++)
            {
                if (arr[i-1]<=j)
                 t[i][j]=t[i-1][j-arr[i-1]] || t[i-1][j];
                else
                 t[i][j]=t[i-1][j]; 
            }
        }
        return t[n][sum];
    }


5.   Equal Sum Partition

ANS.   1st approach ():

       bool subset(vector<int> &arr,int n,int sum)
    {
        int t[n+1][sum+1];
        for (int i=0;i<sum+1;i++)
           t[0][i]=false;
        for (int i=0;i<n+1;i++)
           t[i][0]=true;
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<sum+1;j++)
            {
                if (arr[i-1]<=j)
                 t[i][j]=t[i-1][j-arr[i-1]] || t[i-1][j];
                else
                 t[i][j]=t[i-1][j]; 
            }
        }
        return t[n][sum];
    }
    bool canPartition(vector<int>& nums) {
        int n=nums.size();
        int sum=accumulate(nums.begin(),nums.end(),0);
        if (sum%2==0)
           return subset(nums,n,sum/2);
        else 
            return false;
        
    }


6.    Count of subset sum with a given sum

ANS.   1st approach ():

int mod=1e9+7;
	
	int perfectSum(int arr[], int n, int sum)
	{
	    int t[n+1][sum+1];
	    for (int i=0;i<sum+1;i++)
	       t[0][i]=0;
	    for (int i=0;i<n+1;i++)
	       t[i][0]=1;
	    for (int i=1;i<n+1;i++)
	    {
	        for (int j=0;j<sum+1;j++)
	        {
	            if (arr[i-1]<=j)
	               t[i][j]=(t[i-1][j-arr[i-1]]+t[i-1][j])%mod;
	            else
	               t[i][j]=t[i-1][j];
	        }
	    }
	    return t[n][sum];
	}


7.  Minimum subset sum diffrence

ANS.   1st approach ():

       int minDifference(int arr[], int n)  { 
        int sum=accumulate(arr,arr+n,0);
        int t[n+1][sum+1];

        for (int i=0;i<sum+1;i++)
           t[0][i]=false;
        for (int i=0;i<n+1;i++)
           t[i][0]=true;

        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<sum+1;j++)
            {
                if (arr[i-1]<=j)
                 t[i][j]=t[i-1][j-arr[i-1]] || t[i-1][j];
                else
                 t[i][j]=t[i-1][j]; 
            }
        }
        int mini=INT_MAX;
        for (int i=0;i<=sum/2;i++)
        {
            if (t[n][i]==true)
                mini=min(mini,sum-2*i);
        }
        return mini;
	} 

8.   Count the number of subsets with given diffrence

ANS.  1st approach ():

int countPartitions(int n, int d, vector<int> &arr) {
       int mod=1e9+7;
        int sum=0;
       for (int i=0;i<n;i++)
            sum+=arr[i];
       if ((sum+d)%2!=0) return 0;
       sum=(sum+d)/2;
        int t[n+1][sum+1];
        for (int i=0;i<sum+1;i++)
           t[0][i]=0;
        for (int i=0;i<n+1;i++)
           t[i][0]=1;
        for (int i=1;i<n+1;i++)
        {
            for (int j=0;j<sum+1;j++)
            {
                if (arr[i-1]<=j)
                   t[i][j]=(t[i-1][j-arr[i-1]]+t[i-1][j])%mod;
                else
                   t[i][j]=t[i-1][j]%mod;
            }
        }
        return t[n][sum]%mod;
}

9.  Unbounded KnapSack DP

ANS.   1st approach ():

       int knapSack(int W, int wt[], int val[], int n) 
    { 
         int t[n+1][W+1];
         //base condition
         for (int i=0;i<n+1;i++)
             t[i][0]=0;
         for (int i=0;i<W+1;i++)
             t[0][i]=0;
         
         for (int i=1;i<n+1;i++)
         {
             for (int j=1;j<W+1;j++)
             {
                 if (wt[i-1]<=j)
                  t[i][j]=max(val[i-1]+t[i][j-wt[i-1]],t[i-1][j]);
                 else
                  t[i][j]=t[i-1][j];
             }
         }
         return t[n][W];
    }


10.   Rod Cutting Problem

ANS.  1st approach ():

     int cutRod(int price[], int n) {
        int length[n];
        for (int i=n-1;i>=0;i--)
            length[i]=i+1;
        
        int t[n+1][n+1];
         for (int i=0;i<n+1;i++)
         {
             t[i][0]=0;
             t[0][i]=0;
         }
         for (int i=1;i<n+1;i++)
         {
             for (int j=1;j<n+1;j++)
             {
                 if (length[i-1]<=j)
                  t[i][j]=max(price[i-1]+t[i][j-length[i-1]],t[i-1][j]);
                 else
                  t[i][j]=t[i-1][j];
             }
         }
         return t[n][n];
        
    }


11.   Maximize the cut segements

ANS.   1st approach ():

Note:we have to put the condition of INT_MIN because if of cut segments doesn't add up to given length than we don't have to consider them

more precisely for DP[0][i] = INT_MIN
cause if we check for a knapsack of size i and elements becomes 0 we don't have to count that cut segments that's why INT_MIN will nullify them in max() part

int unbound_knap(int length[] , int n)
{  

    int t[3+1][n+1];
 
     for(int i=0;i<3+1; i++) t[i][0]=0;
     for(int j=0;j<n+1; j++) t[0][j]=INT_MIN;
     
    for(int i=1;i<3+1;i++)
    {
        for(int j=1 ;j<n+1; j++)
        {
            if(length[i-1]<=j)
                t[i][j]= max(1 + t[i][j-length[i-1]] , t[i-1][j]);
            else
                t[i][j]= t[i-1][j];
        }
    }
   return (t[3][n] >= 0) ? t[3][n] :0;
}

    //Function to find the maximum number of cuts.
    int maximizeTheCuts(int n, int x, int y, int z)
    {
    int length[3];
    length[0]=x;
    length[1]=y;
    length[2]=z;
    
    int res= unbound_knap(length, n);  // n= rod length
    return res;
        
    }
};


12.   Coin Change (maximum Number of Ways)

ANS.   1st approach ():

 int change(int amount, vector<int>& coins) {
        int n=coins.size();
        int t[n+1][amount+1];
        for (int i=0;i<amount+1;i++)
            t[0][i]=0;
        for (int i=0;i<n+1;i++)
            t[i][0]=1;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<amount+1;j++)
            {
                if (coins[i-1]<=j)
                    t[i][j]=t[i][j-coins[i-1]]+t[i-1][j];
                else
                    t[i][j]=t[i-1][j];
            }
        }
        return t[n][amount];        
    }


13.   Coin Change (minimum Number of Coins)

ANS.   1st appraoch ():

    int coinChange(vector<int>& coins, int amount) {
        int n=coins.size();
        int t[n+1][amount+1];
        for (int i=0;i<amount+1;i++)
            t[0][i]=INT_MAX-1;
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<amount+1;j++)
            {
                if (coins[i-1]<=j)
                    t[i][j]=min(1+t[i][j-coins[i-1]],t[i-1][j]);
                else
                    t[i][j]=t[i-1][j];
            }
        }
        return  (INT_MAX-1==t[n][amount])?-1:t[n][amount];        
    }


14.   Largest Common Subsequence 

ANS.   1st approach (recursive):

       int LCS(string &x,string &y,int n,int m)
    {
        if (n==0 || m==0)
            return 0;
        if (x[n-1]==y[m-1])
            return 1+LCS(x,y,n-1,m-1);
        else
            return max(LCS(x,y,n-1,m),LCS(x,y,n,m-1));
    }
    int longestCommonSubsequence(string text1, string text2) {
        return LCS(text1,text2,text1.size(),text2.size());
    }


 2nd approach (memoized):

    int LCS(string &x,string &y,int n,int m,vector<vector<int>> t)
    {
        if (n==0 || m==0)
            return 0;
        if (t[n][m]!=-1)
            return t[n][m];
        if (x[n-1]==y[m-1])
            return t[n][m]=1+LCS(x,y,n-1,m-1,t);
        else
            return t[n][m]=max(LCS(x,y,n-1,m,t),LCS(x,y,n,m-1,t));
    }
    int longestCommonSubsequence(string text1, string text2) {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        return LCS(text1,text2,n,m,t);
    }


3rd approach (Bottom Up (DP)):

 int longestCommonSubsequence(string text1, string text2) {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (text1[i-1]==text2[j-1])
                    t[i][j]=1+t[i-1][j-1];
                else
                    t[i][j]=max(t[i-1][j],t[i][j-1]);
            }
        }
        return t[n][m];
        
    }

	
15.   Longest Common Substring

ANS.   1st approach ():

     

       int longestCommonSubstr (string S1, string S2, int n, int m)
    {
        int t[n+1][m+1];
        for (int i=0;i<n+1;i++)
           t[i][0]=0;
        for (int i=0;i<m+1;i++)
           t[0][i]=0;
           
        int count=0;
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (S1[i-1]==S2[j-1])
                {
                    t[i][j]=1+t[i-1][j-1];
                    count=max(count,t[i][j]);
                }
                else
                t[i][j]=0;
                                 
            }
        }
        return count;
           
    }


16.   Printing Longest Common Subsequence

ANS.   1st approach ():

   vector<int> longestCommonSubsequence(vector<int> a, vector<int> b) {
        int n=a.size();
        int m=b.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (a[i-1]==b[j-1])
                    t[i][j]=1+t[i-1][j-1];
                else
                    t[i][j]=max(t[i-1][j],t[i][j-1]);
            }
        }
        vector<int> ans;
        int i=n,j=m;
        while (i>0 && j>0)
        {
            if (a[i-1]==b[j-1])
            {
                ans.push_back(a[i-1]);
                i--;
                j--;
            }
            else if (t[i][j-1]>t[i-1][j])
                j--;
            else
                i--;
        }
        reverse(ans.begin(), ans.end());
        return ans;
        
}




17.   Shortest Common Subsequence

ANS.   1st approach ():

       int longestCommonSubsequence(string text1, string text2) {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (text1[i-1]==text2[j-1])
                    t[i][j]=1+t[i-1][j-1];
                else
                    t[i][j]=max(t[i-1][j],t[i][j-1]);
            }
        }
        return t[n][m];
        
    }
    //Function to find length of shortest common supersequence of two strings.
    int shortestCommonSupersequence(string X, string Y, int m, int n)
    {
        return m+n-longestCommonSubsequence(X,Y);
    }



18.   Printing Shortest Common Subsequence

ANS.   1st approach ():

        string shortestCommonSupersequence(string text1, string text2) {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (text1[i-1]==text2[j-1])
                    t[i][j]=1+t[i-1][j-1];
                else
                    t[i][j]=max(t[i-1][j],t[i][j-1]);
            }
        }
        
        int i=n,j=m;
        string s;
        while(i>0 && j>0) {
            if(text1[i-1] == text2[j-1])
            {
                s.push_back(text1[i-1]);
                i--;
                j--;
            } else {
                if(t[i][j-1] > t[i-1][j]) {
                    s.push_back(text2[j-1]);
                    j--;
                } else {
                    s.push_back(text1[i-1]);
                    i--;
                }
            }
        }
        
        while(i > 0) {
            s.push_back(text1[i-1]);
            i--;
        }
        
        while(j > 0) {
            s.push_back(text2[j-1]);
            j--;
        } 
        
        reverse(s.begin(), s.end());
        return s;
    }


19.    Minimum number of deletions and insertions / 583. Delete Operation for
 Two Strings

ANS.   1st approach ():

        int longestCommonSubsequence(string text1, string text2) {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (text1[i-1]==text2[j-1])
                    t[i][j]=1+t[i-1][j-1];
                else
                    t[i][j]=max(t[i-1][j],t[i][j-1]);
            }
        }
        return t[n][m];
        
    }
	int minOperations(string str1, string str2) 
	{ 
	    return str1.size()+str2.size()-longestCommonSubsequence(str1,str2)*2;
	    
	} 

20.   Minimum ASCII Delete Sum for Two Strings

ANS.   1st approach (instead of adding 1 , we have added ascii value of the character to maximize the lcs):

       int longestCommonSubsequence(string text1, string text2) {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (text1[i-1]==text2[j-1])
                    t[i][j]=text1[i-1]+t[i-1][j-1];
                else
                    t[i][j]=max(t[i-1][j],t[i][j-1]);
            }
        }
        return t[n][m]; 
    }
    int minimumDeleteSum(string s1, string s2) {
        int lcs= longestCommonSubsequence(s1,s2);
        int sum=0;
        for (int a:s1)
            sum+=a;
        for (int a:s2)
            sum+=a;
        sum-=2*lcs;
        return sum;
    }

21.    Longest Palindromic Subsequence

ANS.   1st approach ():

       int longestCommonSubsequence(string text1, string text2) {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (text1[i-1]==text2[j-1])
                    t[i][j]=1+t[i-1][j-1];
                else
                    t[i][j]=max(t[i-1][j],t[i][j-1]);
            }
        }
        return t[n][m];
        
    }
    int longestPalindromeSubseq(string s) {
     string s2=s;
     reverse(s2.begin(),s2.end());
     return longestCommonSubsequence(s,s2);
    }



22.   Minimum number of deletions to make it Palindrome

ANS.   1st approach ():

       int longestCommonSubsequence(string text1, string text2) {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (text1[i-1]==text2[j-1])
                    t[i][j]=1+t[i-1][j-1];
                else
                    t[i][j]=max(t[i-1][j],t[i][j-1]);
            }
        }
        return t[n][m];
    }
int minDeletions(string str, int n) { 
    string s2=str;
    reverse(s2.begin(),s2.end());
    return n-longestCommonSubsequence(str,s2);
} 



23.   Longest Repeating Subsequence

ANS.   1st approach ():

      int longestCommonSubsequence(string text1, string text2) {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (i!=j && text1[i-1]==text2[j-1])
                    t[i][j]=1+t[i-1][j-1];
                else
                    t[i][j]=max(t[i-1][j],t[i][j-1]);
            }
        }
        return t[n][m];
        
    }
		int LongestRepeatingSubsequence(string str){
		    return longestCommonSubsequence(str,str);
		}


24.    Minimum Insertion Steps to Make a String Palindrome

ANS.   1st approach ():

       int longestCommonSubsequence(string text1, string text2) {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (text1[i-1]==text2[j-1])
                    t[i][j]=1+t[i-1][j-1];
                else
                    t[i][j]=max(t[i-1][j],t[i][j-1]);
            }
        }
        return t[n][m];
    }
    int minInsertions(string s) {
         string s2=s;
    reverse(s2.begin(),s2.end());
    return s.size()-longestCommonSubsequence(s,s2);
    }


25.   Printing Longest Palindromic Substring

ANS.   1st approach ():

       string longestCommonSubstr(string S1, string S2, int n, int m)
    {
        int t[n+1][m+1];
        for (int i=0;i<n+1;i++)
           t[i][0]=0;
        for (int i=0;i<m+1;i++)
           t[0][i]=0;
           
        int count=0;
        string res;
        int indexi,indexj;
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (S1[i-1]==S2[j-1])
                {
                    t[i][j]=1+t[i-1][j-1];
                    if (t[i][j]>count)
                    {
                        string temp = S1.substr(i-t[i][j], t[i][j]) ;
                        string revtemp = string(temp.rbegin(),temp.rend());
                        if(revtemp==temp)
                        {
                            count = t[i][j] ;
                            res = temp ;
                        }
                    }
                }
                else
                t[i][j]=0;                   
            }
        }
        return res;
    }
    string longestPalindrome(string s) {
     string s2=s;
     reverse(s2.begin(),s2.end());
     return longestCommonSubstr(s,s2,s.size(),s2.size());
    }

26.   Find the longest subsequence of a string that is a substring of another string

ANS.   1st approach ():

       int maxSubsequenceSubstring(string text1, string text2, int n, int m){
    
    vector<vector<int>> t(n+1,vector<int> (m+1,-1));
        for (int i=0;i<n+1;i++)
            t[i][0]=0;
        for (int i=0;i<m+1;i++)
            t[0][i]=0;
        
        int count=0;
        for (int i=1;i<n+1;i++)
        {
            for (int j=1;j<m+1;j++)
            {
                if (text1[i-1]==text2[j-1])
                {
                    t[i][j]=1+t[i-1][j-1];
                    count=max(count,t[i][j]);
                }
                    
                else
                    t[i][j]=t[i-1][j];
            }
        }
        return count;
}


27.   Matrix Chain Multiplication

ANS.   1st approach (recursive):

       int MCM(int arr[],int lb,int ub)
    {
        if (lb==ub) return 0;
        int mini=INT_MAX;
        for (int k=lb;k<=ub-1;k++)
        {
            int tempans=MCM(arr,lb,k)+MCM(arr,k+1,ub)+arr[lb-1]*arr[k]*arr[ub];
            mini=min(mini,tempans);
        }
        return mini;
    }
    int matrixMultiplication(int N, int arr[])
    {
        return MCM(arr,1,N-1);
    }



    2nd approach (memoized):

    int MCM(int arr[],int lb,int ub, vector<vector<int>> &t)
    {
        if (lb==ub) return 0;
        if (t[lb][ub]!=-1)
          return t[lb][ub];
        int mini=INT_MAX;
        for (int k=lb;k<=ub-1;k++)
        {
            int tempans=MCM(arr,lb,k,t)+MCM(arr,k+1,ub,t)+arr[lb-1]*arr[k]*arr[ub];
            mini=min(mini,tempans);
        }
        return t[lb][ub]=mini;
    }
    int matrixMultiplication(int N, int arr[])
    {
        vector<vector<int>> t(N,vector<int> (N,-1));
        return MCM(arr,1,N-1,t);
    }

   



 

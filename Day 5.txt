                                              SDE SHEET STRIVER


                                                      DAY 5


1.Reverse a LinkedList 

ANS.   1st approach (using three pointer O(n)):

        ListNode* reverseList(ListNode* head) {
        
        ListNode *p=head,*q=nullptr,*r=nullptr;
        
        while (p!=nullptr)
        {
            r=q;
            q=p;
            p=p->next;
            q->next=r;
        }
        head=q;
        return head;
        }


2.Find middle of LinkedList

ANS.   1st approach (traverse to count the no. of nodes and then again traverse for middle  O(n)+O(n/2))  :

       ListNode* middleNode(ListNode* head) {
        int count=0;
        ListNode *p=head;
        while (p)
        {
            count++;
            p=p->next;
        }
        p=head;
        int count2=0;
        while (p)
        {
            count2++;
            if (count2==((count/2)+1))
                break;
            p=p->next;
        }
        return p;
    }


       2nd approach (slow and fast pointer method or tortoise method  O(n/2))  :

       ListNode* middleNode(ListNode* head) {
       ListNode *p=head,*q=head;
        while (q && q->next)
        {
            p=p->next;
            q=q->next->next;
        }
        return p;
       }


3.Merge Two Sorted Lists

ANS.  1st approach (making a new linked list  SC-O(n+m)  TS-O(n+m))  :

      2nd approach (making changes in existing linked lists   O(n+m))  :

       ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode *last=nullptr,*third=nullptr;
        if (l1==nullptr && l2==nullptr)
            return third;
        if (l1==nullptr || l2==nullptr)
        {
            if (l1==nullptr)
            {
                third=l2;
                return third;
            }
            else{
                third=l1;
                return third;
            }
        }
        
        if (l1->val<l2->val)
        {
            third=last=l1;
            l1=l1->next;
            last->next=nullptr;
        }
        else
        {
            third=last=l2;
            l2=l2->next;
            last->next=nullptr;
        }
        
        while (l1 && l2)
        {
           if (l1->val<l2->val)
        {
            last->next=l1;
            last=l1;
            l1=l1->next;
            last->next=nullptr;
            
        }
         else
         {
             
            last->next=l2;
            last=l2;
            l2=l2->next;
            last->next=nullptr;
         }
        }
        
        while (l1)
        {
            last->next=l1;
            last=l1;
            l1=l1->next;
            last->next=nullptr;
        }
        
        while (l2)
        {
           last->next=l2;
            last=l2;
            l2=l2->next;
            last->next=nullptr; 
        }
        
        return third; 
    }
  
4.Remove N-th node from back of LinkedList 

ANS.   1st approach (first counting total number of nodes and then traversing from front to delete that node  O(n)+O(n)) :

        ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *p=head,*q=nullptr;
        int count=0;
        while (p)
        {
            count++;
            p=p->next;
        }
        
        p=head;
        count=count-n;
        
        for (int i=0;i<count;i++)
        {
            q=p;
            p=p->next;
        }
        if (q==nullptr)
        {
            q=head;
            head=head->next;
            delete q;
        }
            
        else{
            q->next=p->next;
            delete p;
        }
        
        return head;
    }
      2nd approach (uisng fast and slow pointer technique   O(n)) :

       ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *f=head,*s=nullptr;
        for (int i=0;i<n-1;i++)
        {
            f=f->next;
        }
        while (f->next!=nullptr)
        {
            if (s==nullptr)
                s=head;
            else
                s=s->next;
            f=f->next;
        }
        if (s==nullptr)
            return head->next;
        
        s->next=s->next->next;
        
        return head; 
    }

5.Delete Node in a Linked List when that node is given

ANS.   1st approach  (copying the right values to the one left   O(n)) :

       void deleteNode(ListNode* node) {
        
      ListNode *p=node,*temp=nullptr;
     while (p->next!=nullptr)
     {
         p->val=p->next->val;
          if (p->next->next==nullptr)
             temp=p;
         p=p->next; 
     } 
        temp->next=nullptr;
    }

      2nd approach (just copy the next value and modify the next link   O(1))  :

       void deleteNode(ListNode* node) {
     
        node->val=node->next->val;
        node->next=node->next->next;
    }


6. Add two numbers as LinkedList 

ANS.   1st approach (O(max(m,n)))  :

       ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        
       ListNode *dummy=new ListNode();
       ListNode *temp=dummy;
       int carry=0;
      while (l1!=nullptr || l2!=nullptr || carry)
      {
          int sum=0;
          if (l1!=nullptr)
          {
              sum+=l1->val;
              l1=l1->next;
          }
          if (l2!=nullptr)
          {
              sum+=l2->val;
              l2=l2->next;
          }
          
          sum+=carry;
          carry=sum/10;
          ListNode *node=new ListNode();
          node->val=sum%10;
          temp->next=node;
          temp=temp->next;
      }
        
        return dummy->next;
    }

       
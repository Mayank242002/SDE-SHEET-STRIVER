                                               SDE SHEET STRIVER


                                                      DAY 6


1.Find intersection point of Y LinkedList

ANS.    1st approach (using two stacks and then traversing from back   TS=O(m)+O(n)  SC=O(m)+O(n)) :

         ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        
        stack<ListNode *> temp1;
        stack<ListNode *> temp2;
        while (headA)
        {
            temp1.push(headA);
            headA=headA->next;
        }
        while (headB)
        {
            temp2.push(headB);
            headB=headB->next;
        }
        ListNode *last=nullptr;
        while (temp1.top()==temp2.top())
        {
            last=temp1.top();
            if (!temp1.empty())
            temp1.pop();
            if (!temp2.empty())
            temp2.pop();
            if (temp1.empty() || temp2.empty())
                break;
        }
        return last; 
    }

    2nd appraoch (counting length and then traversing larger LL upto distance  O(m)+O(m-n)+O(n)) :

     int length(ListNode *p)
    {
        int count=0;
        while (p)
        {
            count++;
            p=p->next;
        }
        return count;
    }
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        
        int m=length(headA);
        int n=length(headB);
        int d=n-m;
        if (m>n)
        {
            ListNode *temp=headA;
            headA=headB;
            headB=temp;
            d=m-n;
        }
        int i=0;
        for (i=0;i<d;i++)
        {
            headB=headB->next;
        }
        while (headA && headB)
        {
            if (headA==headB)
                return headA;
            headA=headA->next;
            headB=headB->next;
        }
        
        return nullptr;
    }

    3rd approach ( O(m)+(n)+(m-n)) :

    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *d1=headA,*d2=headB;
        
        while (d1!=d2)
        {
            if (d1==nullptr)
                d1=headB;
            else
                d1=d1->next;
            
            if (d2==nullptr)
                d2=headA;
            else
                d2=d2->next;    
        }
        return d1;
        
    }


2.Detect a Cycle in Linked List

ANS.    1st approach (Brute force : using hash table   TC=O(N), SC=O(N))  :   


        2nd approach (using fast and slow pointer method   O(n) )  :

        bool hasCycle(ListNode *head) {
        ListNode *p=head,*q=head;
        
        while (q!=nullptr)
        {
            q=q->next;
            p=p->next;
           
            if (q==nullptr)
                return false;
            else
                q=q->next;
            if (p==q)
                return true;
        }
        return false; 
    }


3.Reverse Nodes in k-Group

ANS.   1st approach (O(n/k)) :

       int length(ListNode *p)
    {
        int count=0;
        while (p)
        {
            count++;
            p=p->next;
        }
        return count;
    }
    ListNode* reverseKGroup(ListNode* head, int k) {
        
        if (head==nullptr || k==1)  return head;
        int count=length(head);
        ListNode *dummy=new ListNode();
        dummy->next=head;
        ListNode *cur=dummy,*nex=dummy,*pre=dummy;
        
        while (count>=k)
        {
            cur=pre->next;
            nex=cur->next;
            
            for (int i=1;i<k;i++)
            {
                cur->next=nex->next;
                nex->next=pre->next;
                pre->next=nex;
                nex=cur->next;
            }
            
            pre=cur;
            count-=k;
        }
        
        return dummy->next;
        
        
    }


4.Palindrome Linked List

ANS.    1st approach (reversing the LL and then cheking the elements  TC=O(N)+O(N)+O(N), SC=O(N))  :

          bool isPalindrome(ListNode* head) {
        
        ListNode *p=head;
        vector<int> temp;
        while (p)
        {
            temp.push_back(p->val);
            p=p->next;
        }
        
        p=head;
        ListNode *q=nullptr,*r=nullptr;
        while (p)
        {
            r=q;
            q=p;
            p=p->next;
            q->next=r;
        }
        
        ListNode *newhead=q;
        
        int i=0;
        for (i=0;i<temp.size();i++)
        {
            if (temp[i]!=newhead->val)
                return false;
            newhead=newhead->next;
        }
        
        return true;
        
    }


      2nd approach  (storing values in vector and checking that vector  : TC=O(N)+O(N), SC=O(N)) :

       bool isPalindrome(ListNode* head) {
        
        ListNode *p=head;
        vector<int> temp;
        while (p)
        {
            temp.push_back(p->val);
            p=p->next;
        }
        int j=temp.size()-1;
        for (int i=0;i<j;i++,j--)
        {
            if (temp[i]!=temp[j])
                return false;
        }
        return true;
        
    }

     3rd approach (finding middle and reversing the LL from one rigth to the middle node and then traversing simultaneously  : TC=O(N),SC=O(1)) :

      ListNode* reverse(ListNode *head)
    {
        ListNode *pre=nullptr,*next=nullptr;
        
        while (head!=nullptr)
        {
            next=head->next;
            head->next=pre;
            pre=head;
            head=next;
        }
        return pre;
    }
    bool isPalindrome(ListNode* head) {
     if (head==nullptr || head->next==nullptr)
         return  true;
    ListNode *slow=head,*fast=head;
        while (fast->next!=nullptr && fast->next->next!=nullptr)
        {
            slow=slow->next;
            fast=fast->next->next;
        }
        
        slow->next=reverse(slow->next);
        slow=slow->next;
        
        
        while (slow!=nullptr)
        {
            if (head->val!=slow->val)
                return false;
            head=head->next;
            slow=slow->next;
        }
        
        return true;
    }



5.Find the starting point of the Loop of LinkedList

ANS.    1st approach  (uisng Hash table TC=O(N), SC=O(N)) :

         
        2nd approach (using slow and fast pointer (floyd tortoise method)  O(n)) :

        ListNode *detectCycle(ListNode *head) {
        if (head==nullptr)
            return nullptr;
        ListNode *p=head,*q=head;
        
        do
        {
            p=p->next;
            q=q->next;
            if (q==nullptr || q->next==nullptr)
                return nullptr;
            else
                q=q->next;   
        }  while (p && q && p!=q);
        
        p=head;
        while (p!=q)
        {
            p=p->next;
            q=q->next;
        }
        
        return q;
        
    }


6.Flattening of a LinkedList 

ANS.    1st approach () :

        
        